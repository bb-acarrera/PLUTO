/**
 * This API class is used to describe the interface to rule operations. This base class can be used by rules that
 * do noy interact with the data, for example metadata rules.
 */
class BaseRuleAPI {

	/**
	 * The base constructor. This simply sets <code>this.config</code> to the passed in configuration object. This config object
	 * will be the rule's individual configuration (if any) and additionally contain <code>RootDirectory</code> which defaults to
	 * the application's root directory if not set, <code>TempDirectory</code> which defaults to the application's temporary
	 * directory if not set, <code>OutputEncoding</code> which is set to the rule's Encoding if set or to the ruleset's Encoding
	 * if set, and <code>utf8</code> if none are set, and <code>Encoding</code> which is set to the input file's encoding. (Note
	 * the distinction between <code>Encoding</code> and <code>OutputEncoding</code>. <code>Encoding</code> is set to the source file's encoding and
	 * <code>OutputEncoding</code> is set to the encoding of the file generated by the rule. In general these would be the same
	 * but rule's may want to switch one uncommon encoding for another more common one.)
	 * @param localConfig {object} the rule's configuration as defined in the ruleset file or a standalone config file.
	 */
	constructor(localConfig) {
		this.config = localConfig || {};
	}

	/**
	 * All rules derived from {@link BaseRuleAPI}, {@link RuleAPI}, or {@link MetadataRuleAPI} must implement this method.
	 * This method is the heart of the rule doing whatever is required.
	 * @returns {Error} if the rule cannot perform it's actions at all, otherwise the return value is specific to the base
	 * class of the rule. (MetadataRuleAPI rules should return nothing. RuleAPI methods should call a method, defined
	 * in RuleAPI, to return a filename, stream, or object. The {@link RuleAPI} documentation describes these in more
	 * detail.
	 */
	run() {
		return new Error("run() not implemented.");
	}

	/**
	 * This method takes input from the validator and calls the rule's <code>run()</code> method.
	 * @param data input from the validator. This data should come in one of three objects. <code>\{ file : filename \}</code>
	 * if the input is a filename, <code>\{ data : object \}</code> if the input is a JavaScript object of some unspecified
	 * type (though usually a string), and <code>\{ stream : stream \}</code> if the input is a readable stream.
	 * @returns {Promise} a promise that returns the results of the rules <code>run()</code> method. This will have
	 * the same structure as the <code>data</code> parameter.
	 * @private
	 */
	_run(data) {
		// Called from validator.
		this._data = data;
		return new Promise((resolve, reject) => {
			let runResult = this.run();
			if (runResult instanceof Promise)
				runResult.then((result) => resolve(result), (error) => reject(error));
			else if (runResult instanceof Error)
				reject(runResult);
			else
				resolve(runResult);
		});
	}

	/**
	 * This method indicates whether or not an entire run of a ruleset should fail if this rule fails. Rules which do
	 * simple filtering can probably fail without breaking the entire run of the ruleset but rules which rearrange the
	 * data, for example, should cause the entire run to fail if they fail.
	 * @abstract
	 * @returns {boolean} <code>false</code> by default. Derived classes should choose whether an entire ruleset run should
	 * fail if they fail.
	 */
	shouldRulesetFailOnError() { return true; }

	/**
	 * Use this with {@link Validator#log} to log significant errors.
	 * @static
	 * @returns {string}
	 * @private
	 */
	static get ERROR() { return "Error"; }

	/**
	 * Use this with {@link Validator#log} to log simple warnings.
	 * @static
	 * @returns {string}
	 * @private
	 */
	static get WARNING() { return "Warning"; }

	/**
	 * Use this with {@link Validator#log} when reporting information.
	 * @static
	 * @returns {string}
	 * @private
	 */
	static get INFO() { return "Info"; }

	/**
	 * This is called when the application has something to log.
	 * @param {string} level the level of the log. One of {@link Validator.ERROR}, {@link Validator.WARNING}, or {@link Validator.INFO}.
	 * If null or undefined
	 * then {@link Validator.INFO} is assumed.
	 * @param problemFileName {string} the name of the file causing the log to be generated. (ex. the rule's filename)
	 * @param ruleID the ID of the rule raising the log report or undefined if raised by some file other than a rule.
	 * @param problemDescription {string} a description of the problem encountered.
	 * @private
	 */
	log(level, problemFileName, ruleID, problemDescription, shouldAbort) {
		if (this.config && this.config.validator)
			this.config.validator.log(level, problemFileName, ruleID, problemDescription, shouldAbort || false);
		else if (this.config && this.config._debugLogger)
			this.config._debugLogger.log(level, problemFileName, ruleID, problemDescription);
	}

	/**
	 * Add an error to the log. If this is called and {@link RuleAPI#shouldRulesetFailOnError} returns
	 * <code>true</code> then at the completion of this rule the running of the ruleset will terminate.
	 * @param problemDescription {string} a description of the problem encountered.
	 */
	error(problemDescription) {
		this.log(BaseRuleAPI.ERROR, this.constructor.name, this.config.id, problemDescription, this.shouldRulesetFailOnError());
	}

	/**
	 * Add a warning to the log.
	 * @param problemDescription {string} a description of the problem encountered.
	 */
	warning(problemDescription) {
		this.log(BaseRuleAPI.WARNING, this.constructor.name, this.config.id, problemDescription);
	}

	/**
	 * Add an information report to the log.
	 * @param problemDescription {string} a description of the problem encountered.
	 */
	info(problemDescription) {
		this.log(BaseRuleAPI.INFO, this.constructor.name, this.config.id, problemDescription);
	}
}

module.exports = BaseRuleAPI;	// Export this so derived classes can extend it.
