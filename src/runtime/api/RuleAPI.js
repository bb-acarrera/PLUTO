const BaseRuleAPI = require('./BaseRuleAPI');

/**
 * This API class is used to describe the interface to rule operations. The methods indicate how the
 * data can be passed to and from the rule. Multiple input and output methods can return true. This allows the
 * application to select the best option for connecting two rules together.
 *
 * The class extends EventEmitter so that rules run asynchronously. When a rule completes it should post the static
 * {@link RuleAPI.NEXT} value.
 */
class RuleAPI extends BaseRuleAPI {
	/**
	 * The base constructor. This simply sets <code>this.config</code> to the passed in configuration object. This config object
	 * will be the rule's individual configuration (if any) and additionally contain <code>RootDirectory</code> which defaults to
	 * the application's root directory if not set, <code>TempDirectory</code> which defaults to the application's temporary
	 * directory if not set, <code>OutputEncoding</code> which is set to the rule's Encoding if set or to the ruleset's Encoding
	 * if set, and <code>utf8</code> if none are set, and <code>Encoding</code> which is set to the input file's encoding. (Note
	 * the distinction between <code>Encoding</code> and <code>OutputEncoding</code>. <code>Encoding</code> is set to the source file's encoding and
	 * <code>OutputEncoding</code> is set to the encoding of the file generated by the rule. In general these would be the same
	 * but rule's may want to switch one uncommon encoding for another more common one.)
	 * @param localConfig {object} the rule's configuration as defined in the ruleset file or a standalone config file.
	 */
	constructor(localConfig) {
		super(localConfig);
	}

	/**
	 * If the rule supports receiving and writing data through the STDIN and STDOUT streams by implementing a method
	 * called {@link RuleAPI#useStreams RuleAPI.useStreams} this method should return true otherwise it should return false.
	 * @abstract
	 * @returns {boolean}
	 */
	canUseStreams() {
		return false;
	}

	/**
	 * If the rule supports receiving and writing data through local file system files by implementing a method
	 * called {@link RuleAPI#useFiles RuleAPI.useFiles} this method should return true otherwise it should return false.
	 * @abstract
	 * @returns {boolean}
	 */
	canUseFiles() {
		return false;
	}

	/**
	 * If the rule supports receiving and writing data through a method call by implementing a method called
	 * {@link RuleAPI#useMethod RuleAPI.useMethod} this method should return true otherwise it should return false.
	 * @abstract
	 * @returns {boolean}
	 */
	canUseMethod() {
		return false;
	}

	/**
	 * If the rule supports receiving and writing data through streams this method must be implemented.
	 * On completion the implementation should emit a {@link RuleAPI.NEXT} event with the output stream. (Note that there is no
	 * error stream. It's expected that the rule will collect errors from any error stream and report them to
	 * the validator.error() method. This allows the rule to properly parse any output before posting to the log.)
	 * @param inputStream {stream} a stream from which the rule reads it's input.
	 * @param outputStream {stream} a stream to which the rule writes it's output.
	 * rule will not be considered to have failed if it writes to this stream.
	 * @abstract
	 */
	useStreams(inputStream, outputStream) {
		this.error("canUseStreams() returned true but useStreams() not implemented.");

		setImmediate(() => {
			this.emit(RuleAPI.NEXT, outputStream);
		});
	}

	/**
	 * If the rule supports receiving and writing data through files this method must be implemented.
	 * On completion the rule should emit a {@link RuleAPI.NEXT} event with the name of the resulting file as the single argument.
	 * The application will delete the file when it is no longer required if
	 * it is created in the TempDirectory.
	 * @param filename {string} the fully qualified name of the file to read. The rule must not delete this file.
	 * @abstract
	 */
	useFiles(filename) {
		this.error("canUseFiles() returned true but useFiles() not implemented.");

		setImmediate(() => {
			this.emit(RuleAPI.NEXT, filename);
		});
	}

	/**
	 * If the rule supports receiving and writing data through a single method call this method must be implemented.
	 * On completion the rule should emit a {@link RuleAPI.NEXT} event with the resulting content as the single argument.
	 * @param data {object|string} the data to apply the rule to.
	 * @abstract
	 */
	useMethod(data) {
		this.error("canUseMethod() returned true but useMethod() not implemented.");

		setImmediate(() => {
			this.emit(RuleAPI.NEXT, data);
		});
	}
}

module.exports = RuleAPI;	// Export this so derived classes can extend it.
