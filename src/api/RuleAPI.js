const EventEmitter = require('events');

/**
 * This API class is used to describe the interface to rule operations. The methods indicate how the
 * data can be passed to and from the rule. Multiple input and output methods can return true. This allows the
 * application to select the best option for connecting two rules together.
 *
 * The class extends EventEmitter so that rules run asynchronously. When a rule completes it should post the static
 * {@link RuleAPI.NEXT} value.
 */
class RuleAPI extends EventEmitter {
	/**
	 * Use this to signal that the next rule can be started. For synchronous rules this would be when the
	 * rule completes and for asynchronous rules using streams this would be when data is ready on the output stream.
	 * @example
	 * 		setImmediate(() => {
	 *			this.emit(RuleAPI.NEXT, filename);
	 *		});
	 * @static
	 */
	static get NEXT() { return "next"; }

	/**
	 * The base constructor. This simply sets <code>this.config</code> to the passed in configuration object. This config object
	 * will be the rule's individual configuration (if any) and additionally contain <code>RootDirectory</code> which defaults to
	 * the application's root directory if not set, <code>TempDirectory</code> which defaults to the application's temporary
	 * directory if not set, <code>OutputEncoding</code> which is set to the rule's Encoding if set or to the ruleset's Encoding
	 * if set, and <code>utf8</code> if none are set, and <code>Encoding</code> which is set to the input file's encoding. (Note
	 * the distinction between <code>Encoding</code> and <code>OutputEncoding</code>. <code>Encoding</code> is set to the source file's encoding and
	 * <code>OutputEncoding</code> is set to the encoding of the file generated by the rule. In general these would be the same
	 * but rule's may want to switch one uncommon encoding for another more common one.)
	 * @param localConfig {object} the rule's configuration as defined in the ruleset file or a standalone config file.
	 */
	constructor(localConfig) {
		super();

		this.config = localConfig;
	}

	/**
	 * If the rule supports receiving and writing data through the STDIN and STDOUT streams by implementing a method
	 * called {@link RuleAPI#useStreams RuleAPI.useStreams} this method should return true otherwise it should return false.
	 * @abstract
	 * @returns {boolean}
	 */
	canUseStreams() {
		return false;
	}

	/**
	 * If the rule supports receiving and writing data through local file system files by implementing a method
	 * called {@link RuleAPI#useFiles RuleAPI.useFiles} this method should return true otherwise it should return false.
	 * @abstract
	 * @returns {boolean}
	 */
	canUseFiles() {
		return false;
	}

	/**
	 * If the rule supports receiving and writing data through a method call by implementing a method called
	 * {@link RuleAPI#useMethod RuleAPI.useMethod} this method should return true otherwise it should return false.
	 * @abstract
	 * @returns {boolean}
	 */
	canUseMethod() {
		return false;
	}

	/**
	 * If the rule supports receiving and writing data through streams this method must be implemented.
	 * On completion the implementation should emit a {@link RuleAPI.NEXT} event with the output stream. (Note that there is no
	 * error stream. It's expected that the rule will collect errors from any error stream and report them to
	 * the validator.error() method. This allows the rule to properly parse any output before posting to the log.)
	 * @param inputStream {stream} a stream from which the rule reads it's input.
	 * @param outputStream {stream} a stream to which the rule writes it's output.
	 * rule will not be considered to have failed if it writes to this stream.
	 * @abstract
	 */
	useStreams(inputStream, outputStream) {
		this.error("canUseStreams() returned true but useStreams() not implemented.");

		setImmediate(() => {
			this.emit(RuleAPI.NEXT, outputStream);
		});
	}

	/**
	 * If the rule supports receiving and writing data through files this method must be implemented.
	 * On completion the rule should emit a {@link RuleAPI.NEXT} event with the name of the resulting file as the single argument.
	 * The application will delete the file when it is no longer required if
	 * it is created in the TempDirectory.
	 * @param filename {string} the fully qualified name of the file to read. The rule must not delete this file.
	 * @abstract
	 */
	useFiles(filename) {
		this.error("canUseFiles() returned true but useFiles() not implemented.");

		setImmediate(() => {
			this.emit(RuleAPI.NEXT, filename);
		});
	}

	/**
	 * If the rule supports receiving and writing data through a single method call this method must be implemented.
	 * On completion the rule should emit a {@link RuleAPI.NEXT} event with the resulting content as the single argument.
	 * @param data {object|string} the data to apply the rule to.
	 * @abstract
	 */
	useMethod(data) {
		this.error("canUseMethod() returned true but useMethod() not implemented.");

		setImmediate(() => {
			this.emit(RuleAPI.NEXT, data);
		});
	}

	/**
	 * This method indicates whether or not an entire run of a ruleset should fail if this rule fails. Rules which do
	 * simple filtering can probably fail without breaking the entire run of the ruleset but rules which rearrange the
	 * data, for example, should cause the entire run to fail if they fail.
	 * @abstract
	 * @returns {boolean} <code>false</code> by default. Derived classes should choose whether an entire ruleset run should
	 * fail if they fail.
	 */
	shouldRulesetFailOnError() { return false; }

	/**
	 * Use this with {@link Validator#log} to log significant errors.
	 * @static
	 * @returns {string}
	 * @private
	 */
	static get ERROR() { return "Error"; }

	/**
	 * Use this with {@link Validator#log} to log simple warnings.
	 * @static
	 * @returns {string}
	 * @private
	 */
	static get WARNING() { return "Warning"; }

	/**
	 * Use this with {@link Validator#log} when reporting information.
	 * @static
	 * @returns {string}
	 * @private
	 */
	static get INFO() { return "Info"; }

	/**
	 * This is called when the application has something to log.
	 * @param {string} level the level of the log. One of {@link Validator.ERROR}, {@link Validator.WARNING}, or {@link Validator.INFO}.
	 * If null or undefined
	 * then {@link Validator.INFO} is assumed.
	 * @param problemFileName {string} the name of the file causing the log to be generated. (ex. the rule's filename)
	 * @param problemDescription {string} a description of the problem encountered.
	 * @private
	 */
	log(level, problemFileName, problemDescription) {
		this.config.validator.log(level, problemFileName, problemDescription);
	}

	/**
	 * Add an error to the log.
	 * @param problemDescription {string} a description of the problem encountered.
	 */
	error(problemDescription) {
		this.log(RuleAPI.ERROR, this.constructor.name, problemDescription);
	}

	/**
	 * Add a warning to the log.
	 * @param problemDescription {string} a description of the problem encountered.
	 */
	warning(problemDescription) {
		this.log(RuleAPI.WARNING, this.constructor.name, problemDescription);
	}

	/**
	 * Add an information report to the log.
	 * @param problemDescription {string} a description of the problem encountered.
	 */
	info(problemDescription) {
		this.log(RuleAPI.INFO, this.constructor.name, problemDescription);
	}
}

/*
 * Export "instance" so the application can instantiate instances of this class without knowing the name of the class.
 * @type {RuleAPI}
 */
module.exports = RuleAPI;	// Export this so derived classes can extend it.
module.exports.instance = RuleAPI;	// Export this so the application can instantiate the class without knowing it's name.
